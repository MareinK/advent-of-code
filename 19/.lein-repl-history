(load-file "7b.clj")
42
(load-file "7b.clj")
(bytes "hoi\n")
(byte-array (map (comp byte int) "ascii"))
(vec (byte-array (map (comp byte int) "ascii")))
(vec (byte-array (map (comp byte int) "ascii\n")))
(load-file "7b.clj")
(byte (int "\n"))
(map (comp byte int) "\n")
(byte (int "\n"))
(load-file "7b.clj")
newline
(newline)
system-newline
System/getProperty "line.separator"
(System/getProperty "line.separator")
(load-file "7b.clj")
(System/getProperty "line.separator")
(load-file "7b.clj")
(defn rotate [coll n]
  (concat (drop n coll) (take n coll)))
(rotate [1, 2, 3, 4, 5, 6, 7] 2)
(rotate [1, 2, 3, 4, 5, 6, 7] 10)
(defn rotate [n coll]
  (let [m (mod n (count coll))])
  (concat (drop m coll) (take m coll)))
(defn rotate [n coll]
  (let [m (mod n (count coll))]
    (concat (drop m coll) (take m coll))))
(rotate 2 (range 10))
(rotate 10 (range 10))
(rotate 11 (range 10))
(rotate 21 (range 10))
(load-file "7b.clj")
(load-file "9a.clj")
(load-file "7a.clj")
(load-file "5a.clj")
(load-file "5ab.clj")
(load-file "9a.clj")
(load-file "7a.clj")
(load-file "7b.clj")
(load-file "9a.clj")
(repeat 5 0)
(repeat -5 0)
(load-file "9a.clj")
(def mem [1,2,3])
mem
(def i 2)
i
(vec (concat mem (repeat (- (count mem) i))))
(repeat -5 0)
(load-file "9a.clj")
(time (load-file "9a.clj"))
(time (load-file "9ab.clj"))
 (load-file "9ab.clj")
(time (load-file "9ab.clj"))
 (load-file "9ab.clj")
(time (load-file "9ab.clj"))
(defn pad-opcode [opcode n]
  ; (format (str/join ["%0" (+ n 2) "d"]) opcode))
  (str/join (repeat (- n (count (str n))) "0")) (str n))
(ns aoc
  (:require [clojure.string :as str]))
(defn pad-opcode [opcode n]
  ; (format (str/join ["%0" (+ n 2) "d"]) opcode))
  (str/join (repeat (- n (count (str n))) "0")) (str n))
(pad-opcode [1 3])
(pad-opcode 1 3)
(pad-opcode 1 5)
(pad-opcode 12 5)
(pad-opcode 0112 5)
(pad-opcode 0112 2)
(pad-opcode 12 5)
(defn pad-opcode [opcode n]
  ; (format (str/join ["%0" (+ n 2) "d"]) opcode))
  (apply str/join (repeat (- n (count (str n))) "0")) (str n))
(pad-opcode 12 5)
(defn pad-opcode [opcode n]
  ; (format (str/join ["%0" (+ n 2) "d"]) opcode))
  (str/join (repeat (- n (count (str n))) "0")))
(pad-opcode 12)
(pad-opcode 12 2)
(pad-opcode 12 5)
(defn pad-opcode [opcode n]
  ; (format (str/join ["%0" (+ n 2) "d"]) opcode))
  (str/join (repeat (- -1 n (count (str n))) "0")))
(pad-opcode 12 5)
(defn pad-opcode [opcode n]
  ; (format (str/join ["%0" (+ n 2) "d"]) opcode))
  (str/join (repeat (- n (count (str n)) -1) "0")))
(pad-opcode 12 5)
(defn pad-opcode [opcode n]
  ; (format (str/join ["%0" (+ n 2) "d"]) opcode))
  (str (str/join (repeat (- n (count (str n)) -1) "0")) opcode))
(pad-opcode 12 5)
(pad-opcode 1  5)
(defn pad-opcode [opcode n]
  ; (format (str/join ["%0" (+ n 2) "d"]) opcode))
  (str (str/join (repeat (- n (count (str opcode)) -1) "0")) opcode))
(pad-opcode 12 5)
(pad-opcode 1  5)
 (load-file "9ab.clj")
(pad-opcode 12 5)
(pad-opcode 0112 5)
(pad-opcode 112 5)
(pad-opcode 0112 5)
(pad-opcode 112 5)
(pad-opcode 1012 5)
(defn pad-opcode [opcode n]
  (println (format (str/join ["%0" (+ n 2) "d"]) opcode))
  (str (str/join (repeat (- n (count (str opcode)) -1) "0")) opcode))
(pad-opcode 112 5)
(pad-opcode 112 1)
(pad-opcode 112 2)
(pad-opcode 112 3)
(pad-opcode 112 2)
(pad-opcode 112 3)
(pad-opcode 112 4)
(pad-opcode 112 )
(pad-opcode 112 5)
(pad-opcode 12 5)
(defn pad-opcode [opcode n]
  (println (format (str/join ["%0" (+ n 2) "d"]) opcode))
  (str (str/join (repeat (- n (count (str opcode))) "0")) opcode))
(pad-opcode 12 5)
(defn pad-opcode [opcode n]
  (println (format (str/join ["%0" (+ n 2) "d"]) opcode))
  (str (str/join (repeat (- n (count (str opcode)) -2) "0")) opcode))
(defn pad-opcode [opcode n]
(pad-opcode 112 )
(pad-opcode 112 5)
(pad-opcode 12 5)
(pad-opcode 10102 5)
 (load-file "9ab.clj")
(time (load-file "9ab.clj"))
(for [i (range n)]
      (read-string (str (get opcode (- start i) 0))))
(def test [opcode i] (for [i (range n)]
      (read-string (str (get opcode (- start i) 0))))
)
(defn test [opcode i] (for [i (range n)]
      (read-string (str (get opcode (- start i) 0))))
)
(defn parse-modes [{mem :mem ip :ip} n]
  ; (let [opcode (pad-opcode (get mem ip) n)
  ;       opmodes (subs opcode 0 (- (count opcode) 2))]
  ;   (reverse (map (comp read-string str) opmodes))))
  (let [opcode (str (get mem ip))
        start (- (count opcode) 2)]
    (for [i (range n)]
      (read-string (str (get opcode (- start i) 0))))))
(parse-modes [1] 0)
(parse-modes [2] 0)
(parse-modes [1] 1)
(parse-modes [2] 1)
(parse-modes [3] 1)
(parse-modes [3] 2)
(parse-modes [3] 3)
(parse-modes [13] 3)
(parse-modes [113] 3)
(parse-modes [1113] 3)
(parse-modes [11111113] 3)
(defn parse-modes [{mem :mem ip :ip} n]
  ; (let [opcode (pad-opcode (get mem ip) n)
  ;       opmodes (subs opcode 0 (- (count opcode) 2))]
  ;   (reverse (map (comp read-string str) opmodes))))
  (let [opcode (str (get mem ip))
        start (- (count opcode) 2)]
    (for [i (range n)]
      (read-string (str (nth opcode (- start i) 0))))))
(parse-modes [11111113] 3)
(parse-modes [13] 3)
(parse-modes [3] 3)
(str 12)
nth(str 112)
(nth 1 (str 112))
(nth (str 112) 1)
(nth (str 112) 2)
(nth (str 112) 3)
(nth (str 112) 2)
(load-file "9ab.clj")
(nth "123" -4)
(nth "123" -4 0)
(load-file "9ab.clj")
(/ 10 3)
(int (/ 10 3))
(reverse (str (get mem (int  (/ 1012 100)))))
(reverse (str (int (/ 1012 100))))
(map (comp read-string str) (reverse (str (int (/ 1012 100)))))
(let [modes (map (comp read-string str) (reverse (str (int (/ 1012 100)))))])
(let [modes (map (comp read-string str) (reverse (str (int (/ 1012 100)))))] (count modes))
(let [modes (map (comp read-string str) (reverse (str (int (/ 1012 100)))))] (- 5 (count modes))
(let [modes (map (comp read-string str) (reverse (str (int (/ 1012 100)))))] (- 5 (count modes)))
)
(let [modes (map (comp read-string str) (reverse (str (int (/ 1012 100)))))] (- 5 (count modes)))
(let [modes (map (comp read-string str) (reverse (str (int (/ 1012 100)))))] (concat (repeat (- 5 (count modes)) 0) modes)
)
(reverse (str (int (/ 1012 100))))
(let [modes (map (comp read-string str) (reverse (str (int (/ 1012 100)))))] (concat modes (repeat (- 5 (count modes)) 0))
)
(load-file "9ab.clj")
1
(load-file "processor.clj")
(load-file "9ab.clj")
(time (load-file "9ab.clj"))
(time (load-file "processor.clj"))
(quot 1010100 100)
(str (quot 1010100 100))
(reverse (str (quot 1010100 100)))
(map str (reverse (str (quot 1010100 100))))
(map (comp read-string str) (reverse (str (quot 1010100 100))))
(def modes (map (comp read-string str) (reverse (str (quot 1010100 100)))))
modes
(count modes)
(- 5 (count modes))
(repeat (- 5 (count modes) 0)
)
(def modes (map (comp read-string str) (reverse (str (quot 1010100 100)))))
(repeat (- 5 (count modes)) 0)
(time (load-file "processor.clj"))
(time (load-file "9ab.clj"))
(time (load-file "piping.clj"))
(time (load-file "11a.clj"))
1
(time (load-file "11a.clj"))
1
(time (load-file "11a.clj"))
(map + [[0 0] [0 1]])
(map + [0 0] [0 1])
(map + [1 1] [0 1])
(time (load-file "11a.clj"))
(time (load-file "11b.clj"))
(time (load-file "11a.clj"))
(time (load-file "11b.clj"))
(str "x" "y")
(time (load-file "11b.clj"))
(range 10 5)
(range 10 5 -1)
(time (load-file "11b.clj"))
(time (load-file "11a.clj"))
(time (load-file "11b.clj"))
(time (load-file "11a.clj"))
(time (load-file "11b.clj"))
(time (load-file "11a.clj"))
(time (load-file "11b.clj"))
(time (load-file "11ab.clj"))
(load-file "12a.clj")
(load-file "12b.clj")
(load-file "12a.clj")
(load-file "12b.clj")
(load-file "12a.clj")
(load-file "12b.clj")
(load-file "13a.clj")
(load-file "13b.clj")
(load-file "11ab.clj")
(set! *asd* 1)
(load-file "11ab.clj")
{assoc {} :a 1}
(assoc {} :a 1)
(assoc {} :a 1 :b 2)
(load-file "11ab.clj")
(defrecord State [mem ip rb c-in c-out]) ; memory, instruction pointer, relative base, input channel, output channel
(State. 0 0 0 0 0)
(assoc (State. 0 0 0 0 0) :mem 1)
(load-file "11ab.clj")
(print-cause-trace *e 30)
(use 'clojure.stacktrace)   
(load-file "11ab.clj")
(print-cause-trace *e 30)
(ns aoc
  (:require [clojure.string :as str]
            [clojure.core.async :refer [alt!!]]))
(load-file "processor.clj")
(defn rotate [[x y] r]
  (case r
    0 [(- y) x]
    1 [y (- x)]))
(defn render [panels]
  (let [xs (map first (keys panels))
        ys (map second (keys panels))
        min-x (apply min xs) max-x (apply max xs)
        min-y (apply min ys) max-y (apply max ys)]
    (str/join
     "\n"
     (for [y (range max-y (- min-y 1) -1)]
       (apply str
              (for [x (range min-x (+ max-x 1))]
                (get {0 " " 1 "â–ˆ"} (get panels [x y] 0))))))))
; (defn paint [initial]
;   (let [[send recv wait] (aoc/run-file-async "11.txt")
;         result (atom nil)]
;     (go
;       (loop [panels initial
;              pos [0 0]
;              dir [0 1]]
;         (reset! result panels)
;         (send (get panels pos 0))
;         (let [color (recv)
;               heading (recv)
;               new-dir (rotate dir heading)]
;           (recur
;            (assoc panels pos color)
;            (map + pos new-dir)
;            new-dir))))
;     (wait)
;     @result))
(defn paint [initial]
  (let [[c-in c-out c-res] (aoc/run-file-async "11.txt")]
    (alt!!
      [[c-in 0]] :sent
      c-out :recv)))
; (println (count (paint {})))
(println (render (paint {[0 0] 1})))
(load-file "11ab.clj")
1
(load-file "11ab.clj")
(load-file "11ab.clj")0
(load-file "11ab.clj")
(load-file "15a.clj")
(set)
#{}
(conj [] 1)
(conj [] 1 2 3)
(pop (conj [] 1 2 3))
(conj () 1 2 3)
(pop (conj () 1 2 3))
(peek (conj () 1 2 3))
(peek (conj [] 1 2 3))
(pop (conj [] 1 2 3))
(load-file "15a.clj")
(pop (conj [] 1 2 3))
(pop (conj () 1 2 3))
(defn repair [initial]
  (let [[send recv wait] (aoc/run-file-async "11.txt")
        result (atom nil)]
    (loop [grid {[0 0] 1}
           pos [0 0]
           queue [[0 0]]]
      (reset! result grid)
      (when-not (= (get grid pos) 2)
        (if (= pos (peek queue))
          (recur))))
            ; ))
        ; (send 1)
        ; (let [status (recv)]
        ;   (println status)
        ;     (recur
        ;      (assoc grid pos status)
        ;      pos))))
    ; (wait)
    ;   (wait)
    @result))
(defmethod print-method clojure.lang.PersistentQueue [q, w] ; Overload the printer for queues so they look like fish
  (print-method '<- w)
  (print-method (seq q) w)
  (print-method '-< w))
clojure.lang.PersistentQueue/EMPTY
(conj clojure.lang.PersistentQueue/EMPTY
        :wake-up :shower :brush-teeth)
(def schedule
  (conj clojure.lang.PersistentQueue/EMPTY
        :wake-up :shower :brush-teeth))
(peek schedule)
(pop schedule)
(rest schedule)
(range 1 5)
(map (partial conj schedule) (range 1 5))
(map (partial conj [1 1 2 1]) (range 1 5))
(into schedule ([1 2 3] [4 5 6])
)
(into schedule ([1 2 3] [4 5 6]))
schedule
(apply conj schedule ([1 2 3] [4 5 6]))
([1 2 3] [4 5 6])
[[1 2 3] [4 5 6]]
(into schedule [[1 2 3] [4 5 6]])
(load-file "15a.clj")
(merge {[] [1]}
(merge {[] [1]})
(load-file "15a.clj")
(load-file "11ab.clj")
(load-file "15a.clj")
(conj [] 1)
(conj [] 1 2)
peek((conj [] 1 2))
(peek (conj [] 1 2))
(pop (conj [] 1 2))
(load-file "15a.clj")
(time (load-file "15a.clj"))
(apply map + [[1,2],[3,4]])
(defn stepvec [step]
  (get {1 [0 1], 2 [0 -1], 3 [-1 0], 4 [1 0]} step))
(defn coords [steps]
  (apply map + (map stepvec steps)))
(coords [1 1 1])
(coords [4,4,4,4,3,3,3,3])
(coords [4,4,4,4,3,3,3])
(time (load-file "15a.clj"))
(coords [4,4,4,4,3,3,3])
(time (load-file "15a.clj"))
(disj 0 #{1 2 3 0})
(disj #{1 2 3 0} 0)
(disj #{1 2 3 0} 1)
(disj #{1 2 3 0} nil)
(time (load-file "15a.clj"))
(time (load-file "15ab.clj"))
(take 5 (range 100))
(time (load-file "15ab.clj"))
(vector [1,2,3])
(apply vector [1,2,3])
(time (load-file "15ab.clj"))
(subvec 5 (range 10))
(subvec (range 10) 5)
(subvec [1,2,3,4,5,6,7,8,9,10] 5)
(conj 4 [1,2,3])
(conj [1,2,3] 5)
(time (load-file "15ab.clj"))
(time (load-file "16a.clj"))
(mod 39 10)
(mod -39 10)
(rem -39 10)
(time (load-file "16a.clj"))
(/ 651 33)
(time (load-file "16a.clj"))
(time (load-file "17a.clj"))
(time (load-file "16a.clj"))
(time (load-file "17a.clj"))
(time (load-file "17b.clj"))
(contains? "ab" a)
(contains? "ab" "a)
(contains? "ab" "a")
(time (load-file "17b.clj"))
\n
\\n
(time (load-file "17b.clj"))
(def dirs [\^ \v \< \>])
(contains? dirs \v)
dirs
(contains? dirs "v")
dirs
(contains? [1 2 3 4] 2)
(contains? dirs \v)
(contains? [\v] \v)
(contains? #{\v} \v)
(time (load-file "17b.clj"))
(int " ")
(int \n)
(int \a)
(time (load-file "17b.clj"))
(int \newline)
(time (load-file "17b.clj"))
(for [c "hello"] c)
(time (load-file "17b.clj"))
(time (load-file "13b.clj"))
(time (load-file "13a.clj"))
(time (load-file "13b.clj"))
grep "processor-new" *
(time (load-file "processor-new.clj"))
(time (load-file "18a.clj"))
(time (load-file "processor-new.clj"))
(time (load-file "18a.clj"))
(join #{:a} #{:b})
(ns aoc (:require
         [clojure.string :refer [split-lines]]
         [clojure.set :refer [difference join]]))
(join #{:a} #{:b})
(join #{[:a]} #{[:b]})
#{[:a]}
#{:a}
#{:a :b}
(time (load-file "18a.clj"))
(print-stack-trace (root-cause *e) 30) 
(use 'clojure.stacktrace)    
(time (load-file "18a.clj"))
(print-stack-trace (root-cause *e) 30) 
(time (load-file "18a.clj"))
(print-stack-trace (root-cause *e) 30)
(time (load-file "18a.clj"))
(print-stack-trace *e 30)
(time (load-file "18a.clj"))
(ns aoc (:require
         [clojure.string :refer [split-lines lower-case]]
         [clojure.set :refer [difference]]
         [clojure.data.priority-map :refer [priority-map]]))
(lower-case \A)
(Character/toLowerCase \A)
(time (load-file "18a.clj"))
(time (load-file "18b.clj"))
(time (load-file "18a.clj"))
(time (load-file "18b.clj"))
(time (load-file "18a.clj"))
(time (load-file "18b.clj"))
(time (load-file "18a.clj"))
(time (load-file "19a.clj"))
(time (load-file "19b.clj"))
(time (load-file "19a.clj"))
(time (load-file "19b.clj"))
[
(time (load-file "19b.clj"))
